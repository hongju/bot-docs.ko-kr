---
title: Bot Framework SDK 내 대화 상자 | Microsoft Docs
description: 대화 상자란 무엇이며 Bot Framework SDK 내에서의 작동 방식에 대해 설명합니다.
keywords: 대화 흐름, 프롬프트, 대화 상태, 의도 인식, 단일 턴, 다중 턴, 봇 대화, 대화, 프롬프트, 폭포, 대화 세트
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 04/18/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: caa1938abd6ca2b79f9b42f28f3965413d24d81b
ms.sourcegitcommit: 4086189a9c856fbdc832eb1a1d205e5f1b4e3acd
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/16/2019
ms.locfileid: "65733379"
---
# <a name="dialogs-library"></a>대화 상자 라이브러리

[!INCLUDE [applies-to-v4](../includes/applies-to.md)]

*대화*는 SDK의 중심 개념이며 사용자와 대화를 관리하는 유용한 방법을 제공합니다. 대화는 봇의 프로그램에서 함수처럼 작동하는 봇의 구조입니다. 각각의 대화는 특정 순서로 특정 작업을 수행하도록 설계되었습니다. 개별 대화의 순서를 지정하여 대화를 안내하고, 때로는 사용자에 대한 응답으로, 때로는 어떤 외부 자극에 대한 응답으로 또는 다른 대화로부터 다양한 방식으로 대화를 호출할 수 있습니다.

대화 라이브러리는 봇의 대화를 더 쉽게 관리하기 위해 *프롬프트* 및 *폭포 대화*와 같은 몇 가지 기본 제공 기능을 제공합니다. [프롬프트](#prompts)는 텍스트, 숫자 또는 날짜와 같은 다양한 형식의 정보를 요청하는 데 사용됩니다. [폭포 대화](#waterfall-dialogs)는 여러 단계를 순서대로 결합하여 봇에서 미리 정의된 순서에 따라 쉽게 다음 단계로 정보를 전달할 수 있습니다.

<!-- When we have samples for building your own, add links and one liner about them -->

## <a name="dialogs-and-their-pieces"></a>대화 및 관련 구성 요소

대화 라이브러리에는 대화를 더 유용하게 만들기 위한 몇 가지 구성 요소가 추가로 포함되어 있습니다. 아래에서 설명하는 [다양한 유형의 대화](#dialog-types) 외에도 라이브러리에는 *대화 세트*, *대화 컨텍스트* 및 *대화 결과*에 대한 개념이 포함되어 있습니다.

*대화 세트*는 가장 간단한 용어로 대화의 모음입니다. 이는 프롬프트, 폭포 대화 또는 [구성 요소 대화](#component-dialog)와 같은 것일 수 있습니다. 각각은 대화의 구현이며, 특정 문자열 ID로 설정된 대화에 추가됩니다. 봇에서 대화 세트 내의 특정 대화 또는 프롬프트를 시작하려는 경우 해당 문자열 ID를 사용하여 사용할 대화를 지정합니다.

*대화 컨텍스트*에는 대화와 관련된 정보가 포함되어 있으며, 봇의 턴 처리기 내에서 설정된 대화 세트와 상호 작용하는 데 사용됩니다. 대화 컨텍스트는 현재 턴 컨텍스트, 부모 대화 및 [대화 상태](#dialog-state)를 포함하여 대화 내에서 정보를 유지하는 메서드를 제공합니다. 대화 상자 컨텍스트를 사용하면 해당 문자열 ID를 통해 대화 상자를 시작하거나 현재 대화 상자(예: 여러 단계가 있는 폭포 대화 상자)를 계속할 수 있습니다.

대화가 종료되면 대화의 결과 정보가 있는 *대화 결과*를 반환할 수 있습니다. 이 결과는 호출하는 메서드가 대화 내에서 발생한 상황을 확인하고, 필요한 경우 유지되고 있는 일부 위치에 정보를 저장하기 위해 반환됩니다.

## <a name="dialog-state"></a>Dialog 상태

대화는 다중 턴 대화 및 이와 비슷한 대화를 구현하는 방법이며, 여러 턴에 걸쳐 지속됨 상태를 사용하는 SDK 기능의 한 예입니다. 대화에 상태가 없으면 봇에서 대화 세트 내의 위치 또는 이미 수집된 정보를 인식할 수 없습니다.

대화 기반 봇은 일반적으로 대화 세트 컬렉션을 봇 구현의 멤버 변수로 보유합니다. 해당 대화 세트는 지속됨 상태에 대한 액세스를 제공하는 접근자라는 개체에 대한 핸들을 사용하여 만듭니다. 봇 내의 상태에 대한 배경 지식은 [상태 관리](bot-builder-concept-state.md)를 참조하세요.

봇의 OnTurn 처리기 내에서 봇은 *대화 컨텍스트*를 반환하는 대화 세트에서 *컨텍스트 만들기*를 호출하여 대화 하위 시스템을 초기화합니다. 해당 대화 컨텍스트에는 대화에 필요한 정보가 포함되어 있습니다.

대화 컨텍스트를 만들려면 상태가 필요하며, 이 상태는 대화 세트를 만들 때 제공된 접근자를 사용하여 액세스할 수 있습니다. 해당 접근자를 사용하면 대화 세트에서 적절한 대화 상태를 가져올 수 있습니다. 상태 접근자에 대한 세부 정보는 [대화 및 사용자 데이터 저장](bot-builder-howto-v4-state.md)에서 확인할 수 있습니다.

## <a name="dialog-types"></a>대화 유형

대화는 다음 클래스 계층 구조와 같이 몇 가지 다른 유형, 즉 프롬프트, 폭포 대화 및 구성 요소 대화로 제공됩니다.

![대화 상자 클래스](media/bot-builder-dialog-classes.png)

### <a name="prompts"></a>프롬프트

대화 라이브러리 내의 프롬프트는 사용자에게 정보를 요청하고 해당 응답을 평가하는 쉬운 방법을 제공합니다. 예를 들어 *숫자 프롬프트*의 경우 요청하는 질문 또는 정보를 지정하면 프롬프트에서 자동으로 유효한 숫자 응답을 받았는지 확인합니다. 그러한 경우 대화가 계속될 수 있고, 그렇지 않은 경우 유효한 응답에 대한 메시지가 사용자에게 다시 표시됩니다.

프롬프트는 내부적으로 두 가지 단계로 수행되는 대화입니다. 먼저 프롬프트에서 입력을 요청하며, 다음으로 유효한 값을 반환하거나 다시 프롬프트를 사용하여 처음부터 시작합니다.

프롬프트에는 프롬프트가 호출될 때 제공되는 *프롬프트 옵션*이 있습니다. 여기서는 프롬프트에 표시할 텍스트, 유효성 검사가 실패하는 경우의 재시도 프롬프트 및 프롬프트에 응답하기 위한 선택 항목을 지정할 수 있습니다.

또한 프롬프트를 만들 때 이에 대한 몇 가지 사용자 지정 유효성 검사를 추가하도록 선택할 수 있습니다. 예를 들어 숫자 프롬프트를 사용하여 파티 크기를 가져오려고 했지만 파티 크기는 2보다 크고 12보다 작아야 합니다. 프롬프트는 먼저 유효한 숫자를 받았는지 확인한 다음, 이 숫자가 제공된 경우 사용자 지정 유효성 검사를 실행합니다. 사용자 지정 유효성 검사가 실패하면 위와 같이 사용자에게 다시 프롬프트합니다.

프롬프트가 완료되면 요청된 결과 값을 명시적으로 반환합니다. 해당 값이 반환되면 이 값이 기본 제공된 프롬프트 유효성 검사와 추가로 제공되었을 수도 있는 사용자 지정 유효성 검사를 모두 통과했는지 확인할 수 있습니다.

다양한 프롬프트를 사용하는 방법에 대한 예제는 [대화 라이브러리를 사용하여 사용자 입력을 수집하는 방법](bot-builder-prompts.md)을 참조하세요.

#### <a name="prompt-types"></a>프롬프트 형식

프롬프트는 내부적으로 두 가지 단계로 수행되는 대화입니다. 먼저 프롬프트에서 입력을 요청하며, 다음으로 유효한 값을 반환하거나 다시 프롬프트를 사용하여 처음부터 다시 시작합니다. 대화 라이브러리에서 제공하는 다양한 기본 프롬프트는 다음과 같으며, 각 프롬프트는 다양한 유형의 응답을 수집하는 데 사용됩니다. 기본 프롬프트는 "열" 또는 "열둘"과 같은 자연어 입력을 숫자로 해석하거나 "내일" 또는 "금요일 10시"를 날짜-시간으로 해석할 수 있습니다.

| prompt | 설명 | 반환 |
|:----|:----|:----|
| _첨부 파일 프롬프트_ | 문서 또는 이미지와 같은 하나 이상의 첨부 파일을 요청합니다. | _첨부 파일_ 개체의 컬렉션 |
| _선택 항목 프롬프트_ | 일단의 옵션에서 선택하도록 요청합니다. | _찾은 선택 항목_ 개체 |
| _확인 프롬프트_ | 확인을 요청합니다. | 부울 값입니다. |
| _날짜-시간 프롬프트_ | 날짜-시간을 요청합니다. | _날짜-시간 확인_ 개체의 컬렉션 |
| _숫자 프롬프트_ | 숫자를 요청합니다. | 숫자 값 |
| _텍스트 프롬프트_ | 일반 텍스트 입력을 요청합니다. | 문자열입니다. |

사용자에게 입력을 요청하려면 _텍스트 프롬프트_와 같은 기본 제공 클래스 중 하나를 사용하여 프롬프트를 정의하고 대화 집합에 이를 추가합니다. 프롬프트에는 대화 세트 내에서 고유해야 하는 고정 ID가 있습니다. 각 프롬프트에 대해 사용자 지정 유효성 검사기를 사용할 수 있으며, 일부 프롬프트의 경우 _기본 로캘_을 지정할 수 있습니다. 

#### <a name="prompt-locale"></a>프롬프트 로캘

로캘은 **선택 항목**, **확인**, **날짜-시간** 및 **숫자** 프롬프트의 언어별 동작을 결정하는 데 사용됩니다. 임의의 지정된 사용자 입력에 대해 채널이 사용자의 메시지에서 _로캘_ 속성을 제공한 경우 해당 로캘이 사용됩니다. 그렇지 않으면 프롬프트의 생성자를 호출하거나 나중에 설정하여 프롬프트의 _기본 로캘_이 설정되면 해당 로캘이 사용됩니다. 둘 다 제공되지 않으면 영어("en-us")가 로캘로 사용됩니다. 참고: 로캘은 언어 또는 언어 제품군을 나타내는 2, 3 또는 4개 문자의 ISO 639 코드입니다.

### <a name="waterfall-dialogs"></a>폭포 대화

폭포 대화는 사용자로부터 정보를 수집하거나 일련의 작업을 통해 사용자를 안내하는 데 일반적으로 사용되는 대화의 특정 구현입니다. 대화의 각 단계는 *폭포 단계 컨텍스트*(`step`) 매개 변수를 사용하는 비동기 함수로 구현됩니다. 각 단계에서 봇은 [사용자에게 입력을 프롬프트](bot-builder-prompts.md)하고(또는 자식 대화를 시작할 수 있지만 프롬프트가 되는 경우가 많음), 응답을 기다린 다음, 결과를 다음 단계로 전달합니다. 첫 번째 함수의 결과는 그 다음 함수에 인수로 전달됩니다.

다음 다이어그램에는 폭포 단계의 시퀀스와 수행되는 스택 작업을 보여줍니다. 대화 스택을 사용하는 방법에 대한 자세한 내용은 [대화 사용](#using-dialogs) 섹션을 참조하세요.

![대화 상자 개념](media/bot-builder-dialog-concept.png)

폭포 단계 내에서 폭포 대화 상자의 컨텍스트는 해당 *폭포 단계 컨텍스트*에 저장됩니다. 이것은 현재 턴 컨텍스트와 상태에 대한 액세스를 제공하는 대화 컨텍스트와 비슷합니다. 폭포 단계 컨텍스트 개체를 사용하여 폭포 단계 내에 설정된 대화 상자와 상호 작용합니다.

일반적으로 봇의 턴 논리에서 대화 턴 결과의 상태만 확인하면 되지만, 대화의 폭포 단계 내 또는 봇의 OnTurn 처리기에서 대화의 반환 값을 처리할 수 있습니다.
폭포 단계 내에서 대화 상자는 폭포 단계 컨텍스트의 _result_ 속성에 반환 값을 제공합니다.

#### <a name="waterfall-step-context-properties"></a>폭포 단계 컨텍스트 속성

폭포 단계 컨텍스트에 포함되는 속성은 다음과 같습니다.

* *옵션*: 대화에 대한 입력 정보가 포함되어 있습니다.
* *값*: 컨텍스트에 추가할 수 있는 정보가 포함되어 있으며 후속 단계로 전달됩니다.
* *결과*: 이전 단계의 결과가 포함되어 있습니다.

또한 *next* 메서드가 동일한 턴 내에서 폭포 대화의 다음 단계로 계속 진행되므로 필요한 경우 봇에서 특정 단계를 건너뛸 수 있습니다.

### <a name="component-dialog"></a>구성 요소 대화 상자

사용자에게 거리, 도시 및 우편 번호에 대한 값을 제공하도록 요청하는 주소 대화와 같이 다른 시나리오에서 사용할 재사용 가능한 대화를 작성하려는 경우가 있습니다.

*구성 요소 대화*는 큰 대화 세트를 관리가 용이한 더 작은 구성 요소로 분할하여 특정 시나리오를 처리하는 독립적인 대화를 만드는 전략을 제공합니다. 이러한 각 구성 요소에는 자체의 고유한 대화 세트가 있으며, 이 대화 세트가 포함된 대화 세트를 사용하여 이름 충돌을 방지할 수 있습니다. 자세한 내용은 [구성 요소 대화 방법](bot-builder-compositcontrol.md)을 참조하세요.

## <a name="using-dialogs"></a>대화 사용

대화 컨텍스트를 사용하여 대화를 시작, 계속, 대체 또는 종료할 수 있습니다. 또한 대화 스택의 모든 대화를 취소할 수 있습니다.

대화는 *대화 스택*이라고 하는 프로그래밍 방식의 스택으로 간주할 수 있으며, 한 스택에서 전달하고 비어 있는 경우 대체 역할을 수행하는 턴 처리기를 사용합니다. 해당 스택에서 가장 위쪽에 있는 항목은 *활성 대화*로 간주되며, 대화 컨텍스트에서 모든 입력을 활성 대화로 전달합니다.

대화가 시작되면 스택으로 푸시되며, 그러면 바로 활성 대화가 됩니다. 이는 대화가 종료될 때까지 활성 대화로 유지되거나, [대화 대체](#repeating-a-dialog) 메서드를 통해 제거되거나, 턴 처리기 또는 활성 대화 자체를 통해 다른 대화가 스택에 푸시되어 활성 대화가 됩니다. 이 새 대화가 종료되면 스택에서 꺼내고 아래의 다음 대화가 다시 활성 대화가 됩니다. 이렇게 하면 아래에 설명된 [대화 상자 반복](#repeating-a-dialog) 또는 [대화 분기](#branch-a-conversation)가 허용됩니다.


### <a name="create-the-dialog-context"></a>대화 컨텍스트 만들기

대화 컨텍스트를 만들려면 대화 세트의 *컨텍스트 만들기* 메서드를 호출합니다. 컨텍스트 만들기는 대화 세트의 *대화 상태* 속성을 가져오고 이 속성을 사용하여 대화 컨텍스트를 만듭니다. 그러면 대화 컨텍스트를 사용하여 세트의 대화를 시작, 계속 또는 제어합니다.

대화 상태에 액세스하려면 대화 세트에서 *상태 속성 접근자*를 사용해야 합니다. 접근자는 다른 상태 접근자와 동일한 방식으로 만들어지고 사용되지만, 대화 상태에 기반한 자체 속성으로 만들어집니다. 관리 상태에 대한 자세한 내용은 [상태 관리 항목](bot-builder-concept-state.md)에서 확인할 수 있으며, 대화 상태를 사용하는 방법은 [순차적 대화 흐름](bot-builder-dialog-manage-conversation-flow.md) 방법에 나와 있습니다.

### <a name="to-start-a-dialog"></a>대화 상자를 시작하려면

대화를 시작하려면 시작하려는 *대화 ID*를 대화 컨텍스트의 *대화 시작*, *프롬프트* 또는 *대화 대체* 메서드로 전달합니다.

* 시작 대화 상자 메서드는 스택의 맨 위에 대화 상자를 푸시합니다.
* 대체 대화 상자 메서드는 현재 대화 상자를 스택에서 삭제하고 대체 대화 상자를 스택 위로 푸시합니다. 대체된 대화 상자는 취소되고 인스턴스에 포함된 모든 정보는 삭제됩니다.

_options_ 매개 변수를 사용하여 대화 상자의 새 인스턴스로 정보를 전달합니다.
새 대화 상자에 전달된 옵션은 대화 상자의 어느 단계에서든 단계 컨텍스트의 *options* 속성을 통해 액세스할 수 있습니다.
예제 코드는 [분기 및 루프를 사용하여 고급 대화 흐름 만들기](bot-builder-dialog-manage-complex-conversation-flow.md) 방법을 참조하세요.

### <a name="to-continue-a-dialog"></a>대화를 계속하려면

대화를 계속하려면 *대화 계속* 메서드를 호출합니다. 스택의 맨 위에 대화(활성 대화)가 있는 경우 계속 메서드에서 항상 해당 메서드를 계속합니다. 계속된 대화가 종료되면 제어가 동일한 턴 내에서 계속되는 부모 컨텍스트로 전달됩니다.

단계 컨텍스트의 *values* 속성을 사용하여 턴 사이의 상태를 유지합니다.
이전 턴에서 이 컬렉션에 추가된 모든 값을 후속 턴에서 사용할 수 있습니다.
예제 코드는 [분기 및 루프를 사용하여 고급 대화 흐름 만들기](bot-builder-dialog-manage-complex-conversation-flow.md) 방법을 참조하세요.

### <a name="to-end-a-dialog"></a>대화 상자를 종료하려면

*대화 종료* 메서드는 스택에서 대화를 꺼내 종료하고, 선택적 결과(예: 부모 컨텍스트를 호출한 대화 또는 봇의 턴 처리기)를 해당 부모 컨텍스트에 반환합니다. 이 메서드는 현재 인스턴스를 종료하기 위해 대화 내에서 가장 자주 호출됩니다.

대화 종료 메서드는 대화 컨텍스트가 있는 모든 위치에서 호출할 수 있지만, 현재 활성 대화에서 호출된 봇에 표시됩니다.

> [!TIP]
> *대화 종료* 메서드는 대화의 끝부분에서 명시적으로 호출하는 것이 가장 좋습니다.

### <a name="to-clear-all-dialogs"></a>모든 대화를 지우려면

모든 대화 상자를 스택에서 삭제하려면 대화 상자 컨텍스트의 *cancel all dialogs* 메서드를 호출하여 대화 상자 스택을 지울 수 있습니다.

### <a name="repeating-a-dialog"></a>대화 상자 반복

*대화 바꾸기* 메서드를 사용하여 대화를 자체적으로 바꿔 루프를 만들 수 있습니다.
이는 [복잡한 반복](~/v4sdk/bot-builder-dialog-manage-complex-conversation-flow.md)을 처리하는 좋은 방법이며, 메뉴를 관리하는 데 유용한 기술입니다.

> [!NOTE]
> 현재 대화에 대한 내부 상태를 유지해야 하는 경우 *대화 대체* 메서드 호출에서 대화의 새 인스턴스로 정보를 전달한 다음, 대화를 적절히 초기화해야 합니다.

### <a name="branch-a-conversation"></a>대화 분기

대화 컨텍스트는 대화 스택을 유지하고 스택의 각 대화에 대한 다음 단계를 추적합니다. 대화의 *대화 시작* 메서드는 자식 대화를 만들어 해당 대화를 스택의 맨 위로 푸시하고, *대화 종료* 메서드는 스택에서 맨 위의 대화를 꺼냅니다. *대화 종료*는 일반적으로 종료되는 대화 내에서 호출됩니다.

대화 상자는 대화 상자 컨텍스트의 *begin dialog* 메서드를 호출하고, 새 대화 상자가 현재 활성 대화 상자가 되도록 새 대화 상자의 ID를 제공하여 동일한 대화 상자 집합 내에서 새 대화 상자를 시작할 수 있습니다. 원래 대화 상자는 여전히 스택에 있지만, 대화 상자 컨텍스트의 *continue dialog* 메서드에 대한 호출은 스택 맨 위에 있는 대화 상자인 *활성 대화 상자*에만 전송됩니다. 대화 상자가 스택에서 사라지면 대화 상자 컨텍스트가 원래 대화 상자에서 사라졌던 스택에서 폭포의 다음 단계로 다시 시작됩니다.

따라서 사용 가능한 대화 상자 집합에서 시작할 대화 상자를 조건부로 선택할 수 있는 단계를 하나의 대화 상자에 포함하여 대화 흐름 내에 분기를 만들 수 있습니다.

## <a name="next-steps"></a>다음 단계

> [!div class="nextstepaction"]
> [대화 상자 라이브러리를 사용하여 사용자 입력 수집](bot-builder-prompts.md)
