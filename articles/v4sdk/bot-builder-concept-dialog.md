---
title: Bot Builder SDK 내 대화 상자 | Microsoft Docs
description: 대화 상자란 무엇이며 Bot Builder SDK 내에서의 작동 방식에 대해 설명합니다.
keywords: 대화 흐름, 프롬프트, 대화 상태, 의도 인식, 단일 턴, 다중 턴, 봇 대화, 대화, 프롬프트, 폭포, 대화 세트
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 964d4a0344df595630f5b38fa32b3cc3a526ed5c
ms.sourcegitcommit: bbfb171f515c50a3c8bba5ca898daf25cf764378
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/23/2018
ms.locfileid: "52293595"
---
# <a name="dialogs-library"></a>대화 상자 라이브러리

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

대화 상자라는 개념을 통해 대화를 관리하는 것이 SDK의 핵심입니다. 대화 상자 개체는 인바운드 활동을 처리하고 아웃바운드 응답을 생성합니다. 봇의 비즈니스 논리는 직접 또는 간접적으로 대화 상자 클래스 내에서 실행됩니다.

런타임에서 대화 상자 인스턴스는 스택에 정렬됩니다. 스택의 맨 위에 있는 대화 상자를 ActiveDialog라고 합니다. 현재 활성 대화 상자는 인바운드 활동을 처리합니다. 대화(시간 제한이 없으며 아마도 며칠에 걸친)의 각 턴 간에 스택은 지속됩니다. 

## <a name="dialog-lifecycle"></a>대화 상자 수명 주기

대화 상자는 세 가지 주요 기능을 구현합니다.
- BeginDialog
- ContinueDialog
- ResumeDialog

런타임에서 Dialogs 및 DialogContext 클래스는 함께 작동하여 작업을 처리할 적절한 대화 상자를 선택합니다. DialogContext 클래스는 지속된 대화 상자 스택, 인바운드 활동 및 DialogSet 클래스를 연결합니다. DialogSet은 봇이 호출할 수 있는 대화 상자를 포함합니다.

DialogContext의 인터페이스는 대화 상자 시작 및 연속의 기본 개념을 반영합니다. 응용 프로그램에 대한 일반적인 패턴은 항상 ContinueDialog를 먼저 호출하는 것입니다. 스택이 없어서 ActiveDialog가 없는 경우 응용 프로그램은 DialogContext에서 BeginDialog를 호출하여 선택한 대화 상자를 시작해야 합니다. 그러면 DialogSet의 해당하는 대화 상자 항목(기술적으로 스택에 추가되는 대화 상자의 ID임)이 스택으로 푸시된 다음, 특정 대화 상자 개체의 BeginDialog로 호출을 위임합니다. ActiveDialog가 있었다면 해당 대화 상자에 관련된 지속 속성을 제공하는 과정에서 해당 대화 상자의 ContinueDialog로 간단히 호출을 위임했을 것입니다.

**대화 상자의 BeginDialog**는 초기 코드이고 초기 속성(코드에서 “옵션”이라고 함)을 사용하며, **대화 상자의 ContinueDialog**는 지속성 후에 활동이 도착하면 실행을 계속하기 위해 실행되는 코드입니다. 예를 들어 대화 상자가 사용자에게 질문을 한다고 가정해봅시다. 질문은 BeginDialog에서 이루어지며 대답은 ContinueDialog에 나타납니다.

대화 상자(대화 상자에 자식 대화 상자가 있는)의 중첩을 지원하기 위해 연속의 추가 유형이 있습니다. 이를 재개라고 합니다. DialogContext는 자식 대화 상자가 완료되면 부모 대화 상자에서 ResumeDialog 메서드를 호출합니다.

프롬프트 및 폭포는 모두 SDK에서 제공하는 대화 상자의 구체적인 예제입니다. 이러한 추상화를 작성하여 많은 시나리오가 빌드됩니다. 하지만 내부적으로, 실행된 논리는 여기서 설명한 연속 및 재개 패턴과 같이 항상 동일한 시작입니다. 

Bot Builder SDK의 **대화 상자** 라이브러리에는 봇의 대화를 관리하는 데 도움이 되는 _프롬프트_, _폭포 대화 상자_ 및 _구성 요소 대화 상자_와 같은 기본 제공 기능이 포함됩니다. 프롬프트를 사용하여 사용자에게 다른 유형의 정보를 묻고, 폭포를 사용하여 여러 단계를 시퀀스로 통합하며, 구성 요소 대화 상자를 사용하여 다른 봇에 통합할 수 있도록 대화 상자 논리를 개별 클래스로 패키지할 수 있습니다.
## <a name="waterfall-dialogs-and-prompts"></a>폭포 대화 상자 및 프롬프트

**대화 상자** 라이브러리는 다양한 유형의 프롬프트 집합과 함께 제공되므로 사용자 입력의 다양한 유형을 수집하는 데 사용할 수 있습니다. 예를 들어, 사용자에게 텍스트 입력을 요청하려면 **TextPrompt**를 사용할 수 있습니다. 사용자에게 숫자를 물으려면 **NumberPrompt**를 사용하고, 날짜 및 시간을 물으려면 **DateTimePrompt**를 사용할 수 있습니다. 프롬프트는 대화 상자의 특정 유형입니다. 폭포 대화 상자에서 프롬프트를 사용하려면 동일한 대화 상자 집합에 프롬프트와 폭포를 모두 추가합니다. 

프롬프트-응답 상호 작용의 특성상 프롬프트를 구현하려면 폭포 대화 상자에서 최소한 2단계가 필요합니다. 첫 번째 단계는 프롬프트를 보내고, 두 번째 단계는 응답을 캡처 및 처리합니다.  추가 프롬프트가 있다면 경우에 따라 단일 함수를 사용하여 먼저 사용자의 응답을 처리한 다음, 다음 프롬프트를 시작하도록 이러한 항목을 결합할 수 있습니다.

`WaterfallDialog`는 사용자로부터 정보를 수집하거나 사용자에게 일련의 태스크를 안내하는 데 사용되는 특정 방식의 대화 상자 구현입니다. 태스크는 첫 번째 함수의 결과가 다음 함수의 인수로 전달되는 방식으로 계속 진행되는 함수 배열로 구현됩니다. 각 함수는 일반적으로 전체 프로세스에서 하나의 단계를 나타냅니다. 각 단계에 대해 봇은 사용자에게 입력을 프롬프트하고, 응답을 기다린 다음, 결과를 다음 단계로 전달합니다. 

프롬프트 및 폭포는 모두 다음 클래스 계층에 표시된 것처럼 대화 상자입니다. 

![대화 상자 클래스](media/bot-builder-dialog-classes.png)

폭포 대화 상자는 폭포 단계의 시퀀스로 구성됩니다. 각 단계는 _폭포 단계 컨텍스트_(`step`) 매개 변수를 사용하는 비동기 대리자입니다. 패턴은 폭포 단계에서 수행되는 마지막 항목이 자식 대화 상자(일반적으로 프롬프트)를 시작하거나 자체 폭포를 종료하는 것입니다. 다음 다이어그램에는 폭포 단계의 시퀀스와 수행되는 스택 작업을 보여줍니다.

![대화 상자 개념](media/bot-builder-dialog-concept.png)

턴 처리기의 봇에서 또는 대화 상자의 폭포 단계 내에서 대화 상자의 반환 값을 처리할 수 있습니다.
폭포 단계 내에서 대화 상자는 폭포 단계 컨텍스트의 _result_ 속성에 반환 값을 제공합니다.
일반적으로 봇의 턴 논리로부터 기인한 대화 상자 턴의 상태만 확인하면 됩니다.

## <a name="about-prompt-types"></a>프롬프트 유형 정보

프롬프트는 내부적으로 두 가지 단계로 수행되는 대화입니다. 먼저 프롬프트에서 입력을 요청하며, 다음으로 유효한 값을 반환하거나 다시 프롬프트를 사용하여 처음부터 다시 시작합니다. 대화 라이브러리에서 제공하는 다양한 기본 프롬프트는 다음과 같으며, 각 프롬프트는 다양한 유형의 응답을 수집하는 데 사용됩니다. 기본 프롬프트는 "열" 또는 "열둘"과 같은 자연어 입력을 숫자로 해석하거나 "내일" 또는 "금요일 10시"를 날짜-시간으로 해석할 수 있습니다.

| prompt | 설명 | 반환 |
|:----|:----|:----|
| _첨부 파일 프롬프트_ | 문서 또는 이미지와 같은 하나 이상의 첨부 파일을 요청합니다. | _첨부 파일_ 개체의 컬렉션 |
| _선택 항목 프롬프트_ | 일단의 옵션에서 선택하도록 요청합니다. | _찾은 선택 항목_ 개체 |
| _확인 프롬프트_ | 확인을 요청합니다. | 부울 값입니다. |
| _날짜-시간 프롬프트_ | 날짜-시간을 요청합니다. | _날짜-시간 확인_ 개체의 컬렉션 |
| _숫자 프롬프트_ | 숫자를 요청합니다. | 숫자 값 |
| _텍스트 프롬프트_ | 일반 텍스트 입력을 요청합니다. | 문자열입니다. |

사용자에게 입력을 요청하려면 _텍스트 프롬프트_와 같은 기본 제공 클래스 중 하나를 사용하여 프롬프트를 정의하고 대화 집합에 이를 추가합니다. 프롬프트에는 대화 세트 내에서 고유해야 하는 고정 ID가 있습니다. 각 프롬프트에 대해 사용자 지정 유효성 검사기를 사용할 수 있으며, 일부 프롬프트의 경우 _기본 로캘_을 지정할 수 있습니다. 

### <a name="prompt-locale"></a>프롬프트 로캘

로캘은 **선택 항목**, **확인**, **날짜-시간** 및 **숫자** 프롬프트의 언어별 동작을 결정하는 데 사용됩니다. 임의의 지정된 사용자 입력에 대해 채널이 사용자의 메시지에서 _로캘_ 속성을 제공한 경우 해당 로캘이 사용됩니다. 그렇지 않으면 프롬프트의 생성자를 호출하거나 나중에 설정하여 프롬프트의 _기본 로캘_이 설정되면 해당 로캘이 사용됩니다. 둘 다 제공되지 않으면 영어("en-us")가 로캘로 사용됩니다. 참고: 로캘은 언어 또는 언어 제품군을 나타내는 2, 3 또는 4개 문자의 ISO 639 코드입니다.

## <a name="dialog-state"></a>Dialog 상태

대화는 다중 턴 대화 및 이와 비슷한 대화를 구현하는 방법이며, 여러 턴에 걸쳐 지속됨 상태를 사용하는 SDK 기능의 한 예입니다. 대화에 상태가 없으면 봇에서 대화 세트 내의 위치 또는 이미 수집된 정보를 인식할 수 없습니다.

대화 기반 봇은 일반적으로 대화 세트 컬렉션을 봇 구현의 멤버 변수로 보유합니다. 해당 대화 세트는 지속됨 상태에 대한 액세스를 제공하는 접근자라는 개체에 대한 핸들을 사용하여 만듭니다. 봇 내의 상태에 대한 배경 지식은 [상태 관리](bot-builder-concept-state.md)를 참조하세요. 

![Dialog 상태](media/bot-builder-dialog-state.png)

봇의 턴 처리기가 호출되면 봇은 *대화 컨텍스트*이 반환하는 대화 세트에서 *컨텍스트 만들기*를 호출하여 대화 하위 시스템을 초기화합니다. 대화 컨텍스트를 만들려면 상태가 필요하며, 이 상태는 대화 세트를 만들 때 제공된 접근자를 사용하여 액세스할 수 있습니다. 해당 접근자를 사용하면 대화 세트에서 적절한 대화 상태 JSON을 가져올 수 있습니다. 해당 대화 컨텍스트에는 대화에 필요한 정보가 포함되어 있습니다.

상태 접근자에 대한 세부 정보는 [대화 및 사용자 데이터 저장](bot-builder-howto-v4-state.md)에서 확인할 수 있습니다.

## <a name="repeating-a-dialog"></a>대화 상자 반복

대화 상자를 반복하려면 *replace dialog* 메서드를 사용합니다. 대화 상자 컨텍스트의 *replace dialog* 메서드는 현재 대화 상자를 스택에서 삭제하고 대체 대화 상자를 스택의 맨 위로 푸시하여 해당 대화 상자를 시작합니다. 이 메서드를 사용하여 다이얼로그를 자체로 대체하여 루프를 만들 수 있습니다. 현재 대화 상자에 대한 내부 상태를 유지해야 할 경우 _replace dialog_ 메서드에 대한 호출에서 대화 상자의 새 인스턴스로 정보를 전달한 다음, 대화 상자를 적절하게 시작해야 합니다. 새 대화 상자에 전달된 옵션은 대화 상자의 어느 단계에서든 단계 컨텍스트의 _options_ 속성을 통해 액세스할 수 있습니다. 이는 복잡한 대화 흐름을 처리하거나 메뉴를 관리하는 데 좋은 방법입니다.

## <a name="branch-a-conversation"></a>대화 분기

다이얼로그 컨텍스트는 _다이얼로그 스택_을 유지하고 스택의 각 다이얼로그에 대해 다음 단계를 추적합니다. _begin dialog_ 메서드는 대화 상자를 스택의 맨 위로 푸시하고, _end dialog_ 메서드는 스택에서 맨 위의 대화 상자를 삭제합니다.

대화 상자는 대화 상자 컨텍스트의 _begin dialog_ 메서드를 호출하고, 새 대화 상자가 현재 활성 대화 상자가 되도록 새 대화 상자의 ID를 제공하여 동일한 대화 상자 집합 내에서 새 대화 상자를 시작할 수 있습니다. 원래 대화 상자는 여전히 스택에 있지만, 대화 상자 컨텍스트의 _continue dialog_ 메서드에 대한 호출은 스택 맨 위에 있는 대화 상자인 _활성 대화 상자_에만 전송됩니다. 대화 상자가 스택에서 사라지면 대화 상자 컨텍스트가 원래 대화 상자에서 사라졌던 스택에서 폭포의 다음 단계로 다시 시작됩니다.

따라서 사용 가능한 대화 상자 집합에서 시작할 대화 상자를 조건부로 선택할 수 있는 단계를 하나의 대화 상자에 포함하여 대화 흐름 내에 분기를 만들 수 있습니다.

## <a name="component-dialog"></a>구성 요소 대화 상자
경우에 따라 다양한 시나리오에서 사용하려는 재사용 가능 대화 상자를 작성하고자 합니다. 거리, 도시 및 우편 번호에 대한 값을 입력하도록 사용자에게 요청하는 주소 대화 상자를 예로 들 수 있습니다. 

ComponentDialog는 별도의 DialogSet가 있기 때문에 격리 수준을 제공합니다. 별도의 DialogSet가 있으므로 대화 상자를 포함한 부모를 사용하여 이름 충돌을 방지하고, 자체 독립적인 내부 대화 상자 런타임을 만들고(자체 DialogContext를 만들어서), 활동을 디스패치합니다. 이 보조 디스패치는 활동을 가로챌 수 있는 기회가 있음을 의미합니다. 이는 “help” 및 “cancel”과 같은 기능을 구현하려고 할 때 매우 유용할 수 있습니다.  [엔터프라이즈 봇 템플릿](https://aka.ms/abs/templates/cabot) 샘플을 참조하세요. 

## <a name="next-steps"></a>다음 단계

> [!div class="nextstepaction"]
> [대화 상자 라이브러리를 사용하여 사용자 입력 수집](bot-builder-prompts.md)
