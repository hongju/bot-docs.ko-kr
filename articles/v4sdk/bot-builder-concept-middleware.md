---
title: 미들웨어 | Microsoft Docs
description: 미들웨어를 이해하고 봇 SDK에서 어떤 용도로 사용되는지 알아봅니다.
keywords: 미들웨어, 미들웨어 파이프라인, 단락, 미들웨어 사용
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 05/23/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: c70470d66d1402fc3d4c29d8772193f8e0576913
ms.sourcegitcommit: ea64a56acfabc6a9c1576ebf9f17ac81e7e2a6b7
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/24/2019
ms.locfileid: "66215489"
---
# <a name="middleware"></a>미들웨어

[!INCLUDE [applies-to-v4](../includes/applies-to.md)]

미들웨어는 간단하게 말해서 어댑터와 봇 논리 사이에 위치하는 클래스로, 초기화하는 동안 어댑터의 미들웨어 컬렉션에 추가됩니다. SDK를 사용하면 사용자 고유의 미들웨어를 작성하거나 다른 사람이 만든 미들웨어를 추가할 수 있습니다. 봇으로 들어오거나 봇에서 나가는 모든 작업은 미들웨어를 통과합니다.

어댑터는 봇 미들웨어 파이프라인을 통해 들어오는 작업을 처리하고 봇의 논리로 안내한 후 다시 밖으로 내보냅니다. 각 작업이 봇으로 들어가고 나올 때 미들웨어의 각 부분은 봇 논리가 실행되기 전과 후에 작업을 검사하거나 작업에 따라 작동합니다.

미들웨어를 살펴보기 전에, 먼저 [봇의 일반론](~/v4sdk/bot-builder-basics.md) 및 [봇이 작업을 처리하는 방식](~/v4sdk/bot-builder-basics.md#the-activity-processing-stack)을 이해해야 합니다.

## <a name="uses-for-middleware"></a>미들웨어 사용
"작업은 일반 봇 논리를 사용하는 대신 미들웨어로 언제 구현해야 하나요?"라는 질문이 자주 제기됩니다. 미들웨어는 대화가 처리되는 _순서_의 전과 후에 사용자의 대화 흐름과 상호 작용하는 추가 기회를 제공합니다. 또한 미들웨어는 대화와 관련된 정보를 저장 및 검색하고 필요한 경우 추가 처리 논리를 호출할 수 있습니다. 아래는 미들웨어가 유용할 수 있는 일반적인 시나리오입니다.

### <a name="looking-at-or-acting-on-every-activity"></a>모든 작업을 살펴보거나 모든 작업에 따라 작동
봇이 모든 작업 또는 특정 유형의 모든 작업에 대해 무언가를 해야 하는 여러 상황이 있습니다. 예를 들어 봇이 수신하는 모든 메시지 작업을 기록하거나, 봇이 이 순서에 대한 응답을 생성하지 않으면 대체 응답을 제공하려는 경우가 있습니다. 미들웨어는 나머지 봇 논리가 실행되기 전과 후에 작동하는 기능을 갖고 있기 때문에 이 시나리오를 구현하기에 매우 좋습니다.

### <a name="modifying-or-enhancing-the-turn-context"></a>턴 컨텍스트 수정 또는 개선
작업에 제공되는 정보보다 더 많은 정보를 봇이 갖고 있으면 특정 대화가 훨씬 유익할 수 있습니다. 이 경우 미들웨어는 지금까지의 대화 상태 정보를 살펴보고, 외부 데이터 원본을 쿼리하고, [턴 컨텍스트](~/v4sdk/bot-builder-basics.md#defining-a-turn) 개체에 추가한 후 봇 논리에 대한 실행을 전달할 수 있습니다. 

SDK는 들어오고 나가는 활동을 기록할 수 있는 로깅 미들웨어를 정의하지만, 사용자 고유의 미들웨어를 정의할 수도 있습니다.

## <a name="the-bot-middleware-pipeline"></a>봇 미들웨어 파이프라인
각 작업에 대해 어댑터는 미들웨어를 추가된 순서대로 호출합니다. 어댑터는 턴 및 _다음_ 대리자에 대한 컨텍스트 개체를 전달하고, 미들웨어는 파이프라인의 다음 미들웨어에 컨트롤을 전달할 대리자를 호출합니다. 또한 미들웨어는 _다음_ 대리자가 메서드를 반환한 후부터 완료하기 전까지 작업을 수행할 수 있는 기회가 있습니다. 각 미들웨어 개체에는 파이프라인에서 따르는 미들웨어 개체와 관련하여 작동할 수 있는 처음이자 마지막 기회가 있는 것으로 생각하셔도 좋습니다.

예:

- 첫 번째 미들웨어 개체의 턴 처리기가 _다음_ 을 호출하기 전에 코드를 실행합니다.
  - 두 번째 미들웨어 개체의 턴 처리기가 _다음_ 을 호출하기 전에 코드를 실행합니다.
    - 봇의 턴 처리기가 실행 및 반환됩니다.
  - 두 번째 미들웨어 개체의 턴 처리기가 나머지 코드를 실행한 후 반환됩니다.
- 첫 번째 미들웨어 개체의 턴 처리기가 나머지 코드를 실행한 후 반환됩니다.

미들웨어가 다음 대리자를 호출하지 않으면 어댑터가 후속 미들웨어 또는 봇 턴 처리기를 호출하지 않고 파이프라인이 단락됩니다.

봇 미들웨어 파이프라인이 완료되면 턴이 끝나고, 턴 컨텍스트가 범위를 벗어납니다.

미들웨어 또는 봇은 응답을 생성하고 응답 이벤트 처리기를 등록할 수 있지만, 응답이 별도의 프로세스에서 처리된다는 사실을 기억해야 합니다.

## <a name="order-of-middleware"></a>미들웨어 순서
미들웨어가 추가되는 순서에 따라 미들웨어가 작업을 처리하는 순서가 결정되므로 미들웨어 추가 순서를 결정하는 것이 중요합니다.

> [!NOTE]
> 이것은 대부분의 봇에서 작동하는 일반적인 패턴을 제공하기 위한 의도이지만, 미들웨어의 각 부분이 상황에 맞게 상호 작용하는 방식을 고려해야 합니다.

미들웨어 파이프라인의 첫 번째 작업은 매번 사용되는 최하위 수준 작업을 처리하는 것일 확률이 높습니다. 로깅, 예외 처리, 변역을 예로 들 수 있습니다. 순서는 들어오는 메시지를 먼저 번역할 것인지, 메시지가 저장되기 전에 할 것인지 등의 요구 사항에 따라 달라질 수 있으며, 메시지 저장이 먼저 발생하는 경우 저장된 메시지가 번역되지 않을 수 있습니다.

미들웨어 파이프라인의 마지막은 봇 관련 미들웨어로, 봇으로 전송된 모든 메시지에 대한 처리 작업을 수행하도록 구현하는 미들웨어입니다. 미들웨어가 상태 정보 또는 봇 컨텍스트에 설정된 기타 정보를 사용하는 경우 상태 또는 컨텍스트를 수정하는 미들웨어 뒤에 있는 미들웨어 파이프라인에 해당 미들웨어를 추가합니다.

## <a name="short-circuiting"></a>단락
미들웨어 및 응답 처리기와 관련된 중요한 개념 중 하나는 _단락_ 입니다. 이어지는 레이어를 통해 예외가 계속되는 경우 미들웨어(또는 응답 처리기)는 해당 _다음_ 대리자를 호출하여 실행을 전달해야 합니다.  해당 미들웨어(또는 응답 처리기) 내에서 다음 대리자를 호출하지 않으면 연결된 파이프라인이 단락되고 후속 레이어가 실행되지 않습니다. 즉, 모든 봇 논리와 파이프라인에서 그 뒤에 있는 미들웨어를 건너뜁니다. 미들웨어와 응답 처리기의 순서 단락 간에는 미묘한 차이가 있습니다.

미들웨어가 순서를 단락시키는 경우 봇 순서 처리기는 호출되지 않지만, 파이프라인에서 이 시점 전에 실행된 모든 미들웨어 코드는 완료될 때까지 계속 실행됩니다. 

이벤트 처리기의 경우 _다음_ 을 호출하지 않으면 이벤트가 취소되고, 미들웨어 건너뛰기 논리와 크게 다른 결과로 이어집니다. 어댑터는 이벤트의 나머지 부분을 처리하지 않음으로써 절대로 이벤트를 보내지 않습니다.

> [!TIP]
> `SendActivities`처럼 응답 이벤트를 단락시키는 경우 본인이 의도한 동작이어야 합니다. 그렇지 않으면 버그를 수정하기가 어려울 수 있습니다.

## <a name="response-event-handlers"></a>응답 이벤트 처리기
애플리케이션 및 미들웨어 논리 외에도, 컨텍스트 개체에 응답 처리기(이벤트 처리기 또는 작업 이벤트 처리기라고도 함)를 추가할 수 있습니다. 이러한 처리기는 현재 컨텍스트 개체에서 관련 응답이 발생하면 실제 응답을 실행하기 전에 호출됩니다. 이러한 처리기는 실제 이벤트 전에 또는 후에 현재 응답의 나머지 부분에서 해당 형식의 모든 작업에 대해 무엇을 할 것인지 알고 있는 경우에 유용 합니다.

> [!WARNING]
> 각 응답 이벤트 처리기 내부에서 해당 작업 응답 메서드를 호출하지 않도록 주의해야 합니다. 예를 들어 on send activity 처리기 내에서 send activity 메서드를 호출하면 안 됩니다. 호출하면 무한 루프가 생성될 수 있습니다.

새 작업마다 실행할 새 스레드가 생깁니다. 작업을 처리하는 스레드가 생성되면 해당 작업에 대한 처리기 목록이 해당하는 새 스레드에 복사됩니다. 해당 시점 이후 추가된 처리기는 해당 활동 이벤트에 대해 실행되지 않습니다.
컨텍스트 개체에 등록된 처리기는 어댑터에서 미들웨어 파이프라인을 관리하는 방법과 매우 비슷하게 처리됩니다. 즉, 처리기는 추가된 순서대로 호출되며, 다음 대리자를 호출하면 등록된 그 다음 이벤트 처리기에 컨트롤이 전달됩니다. 처리기가 다음 대리자를 호출하지 않으면 후속 이벤트 처리기는 호출되지 않으며 단락 이벤트 및 어댑터는 채널에 응답을 보내지 않습니다.

## <a name="handling-state-in-middleware"></a>미들웨어의 상태 처리

상태를 저장하는 일반적인 방법은 턴 처리기의 끝에서 변경 내용 저장 메서드를 호출하는 것입니다. 호출에 초점을 맞춘 다이어그램은 다음과 같습니다.

![상태 미들웨어 문제](media/bot-builder-dialog-state-problem.png)

이 방법의 문제는 봇의 턴 처리기가 반환되면 발생하는 일부 사용자 지정 미들웨어에서 수행된 모든 상태 업데이트가 지속형 스토리지에 저장되지 않는다는 것입니다. 해결 방법은 _변경 내용 자동 저장_ 미들웨어의 인스턴스를 미들웨어 스택의 시작 부분에 추가하거나 적어도 상태를 업데이트할 수 있는 미들웨어 앞에 추가하여 사용자 지정 미들웨어가 완료된 후에 호출을 변경 내용 저장 메서드로 이동하는 것입니다. 실행은 아래와 같습니다.

![상태 미들웨어 해결 방법](media/bot-builder-dialog-state-solution.png)

업데이트해야 하는 상태 관리 개체를 _봇 상태 세트_ 개체에 추가한 다음, 변경 내용 자동 저장 미들웨어를 만들 때 이 개체를 사용합니다.


## <a name="additional-resources"></a>추가 리소스
Bot Framework SDK [[C#](https://github.com/Microsoft/botbuilder-dotnet/blob/master/libraries/Microsoft.Bot.Builder/TranscriptLoggerMiddleware.cs) | [JS](https://github.com/Microsoft/botbuilder-js/blob/master/libraries/botbuilder-core/src/transcriptLogger.ts)]에 구현된 대본 로거 미들웨어를 살펴볼 수 있습니다.
